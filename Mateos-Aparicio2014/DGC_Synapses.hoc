
load_file("nrngui.hoc")




func choose_index() { local i, x, Lsum localobj idxs, weights, r
    
    idxs = $o1
    weights = $o2
    r = $o3
    
    if (idxs.size() > 0) {
        x = r.repick()
        for i=0, weights.size()-1 {
            if (x < weights.x[i]) {
                break
            } else {
                x = x-weights.x[i]
            }
        }
        return idxs.x[i]
    } else {
       return -1
   }
   
}

obfunc Lweights () { local i, Lsum localobj sects, lengths, weights
    
    sects = $o1
    
    Lsum = 0
    lengths = new Vector()
    weights = new Vector()
    forsec sects {
        lengths.append(L)
        Lsum = Lsum + L
    }
    for i = 0, lengths.size()-1 {
        weights.append(lengths.x[i]/Lsum)
    }
    
    
    return weights 
}


// LPP and MPP synapses: because the number of PP synapses is
// variable, function addSyn is used to add synapses PP per section.

func addSyn () { local i, secindex, syntype, synidx, node, x localobj syn
    
    syntype = $1
    secindex = $2
    node    = $3
    
    synidx = -1
    
    //printf("addSyn: syntype = %d secindex = %d node = %d\n", syntype, secindex, node)
  
    if (syntype == 8) { 
        // LPP-GC synapses; location is MMML/OMML
        x = nodesecmap.x[node]
        assert ((x >= 0.0) && (x <= 1.0), "invalid synapse node location")
        assert(secindex < nDends, "invalid section index")            
        alldendritesList.o(secindex) { 
            syn = new Exp2Syn(x) 
            syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0.0
            syns_LPP.append(syn)
        }
        synidx = syns_LPP.count()-1
    } else if  (syntype == 9) { 
        
        // MPP-GC synapses; location is MMML/OMML
            x = nodesecmap.x[node]
            assert ((x >= 0.0) && (x <= 1.0), "invalid synapse node location")
            assert(secindex < nDends, "invalid section index")            
            alldendritesList.o(secindex) { 
                syn = new Exp2Syn(x) 
                syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0.0
		syns_MPP.append(syn)
            }
            synidx = syns_MPP.count()-1
        }
        
    return synidx
}
    

proc synapses() { local i, j, k, x, Lsum localobj syn, lst, rs, rx, lengths
    
    nsyns_GC   = 1
    nsyns_MC   = 1
    nsyns_HC   = 4
    nsyns_BC   = 10
    nsyns_AA   = 4
    nsyns_HCC  = 10
    nsyns_NGFC = 10
    naxons_AA = 3
    nsyns_LPP   = 1500
    nsyns_MPP   = 1200
    
    // Generate a new random stream, setting
    //	aside 'random_stream_offset' random numbers
    //	for this cell based on its gid
    rs = new Random()
    rs.Random123(random_stream_offset,gid)
    rs.uniform(0,1)
    
    // random stream to generate synapse location within its compartment
    rx = new Random()
    rx.Random123(random_stream_offset+1,gid)
    rx.uniform(0,1)
    
    // Calculate the length-dependent weights for each group of dendritic compartments
    GCLDweights = Lweights(GCLDs)
    PDweights   = Lweights(PDs)
    MDweights   = Lweights(MDs)
    DDweights   = Lweights(DDs)
    
    // Create combined indices and weights for the GCL+IML and MML+OML cases
    GCLPDweights = new Vector()
    GCLPDweights.append(GCLDweights)
    GCLPDweights.append(PDweights)
    
    GCLPDidxs = new Vector()
    GCLPDidxs.append(GCLDidxs)
    GCLPDidxs.append(PDidxs)
    
    MDDweights = new Vector()
    MDDweights.append(DDweights)
    MDDweights.append(MDweights)
    
    MDDidxs = new Vector()
    MDDidxs.append(DDidxs)
    MDDidxs.append(MDidxs)
    
    // GC-GC synapses; location is GCL/IML
    for i=0, nsyns_GC {
        j = choose_index(GCLPDidxs,GCLPDweights,rs) // randomly select GCL dendrite
        dendrites[j] { 
            syn = new Exp2Syn(0.5)
            syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
        } 
        syns_GC.append(syn)
    }
    
    // MC-GC synapses; location is IML
    for i=0, nsyns_MC-1 {
        j = choose_index(PDidxs,PDweights,rs) // randomly select proximal dendrite
        dendrites[j] { 
            syn = new Exp2Syn(rx.repick()) 
            syn.tau1 = 1.5	syn.tau2 = 5.5	syn.e = 0
        }
        syns_MC.append(syn)
    }

    // HC-GC synapses; location is MMML/MOML
    for i=0, nsyns_HC-1 {
        j = choose_index(MDDidxs,MDDweights,rs) // randomly select middle/distal dendrite
        dendrites[j] { 
            syn = new Exp2Syn(rx.repick()) 
            syn.tau1 = 0.05  	syn.tau2 = 1.25	syn.e = -85.7 //syn.e = -28.99
        }
        syns_HC.append(syn)
    }
    
    // BC-GC synapses; location is soma/GCL
    for i=0, nsyns_BC-2 {
        j = choose_index(GCLDidxs,GCLDweights,rs) // randomly select GCL dendrite
        dendrites[j] { 
            syn = new Exp2Syn(rx.repick())
            syn.tau1 = 0.25 syn.tau2 = 2.5 syn.e = -28.99
        }
        syns_BC.append(syn)
    }
    soma { 
            syn = new Exp2Syn(rx.repick())
            syn.tau1 = 0.25 syn.tau2 = 2.5 syn.e = -28.99
        }
    syns_BC.append(syn)
    
    // AA-GC synapses; location is GC axon
    for i=0, nsyns_AA-1 {
        x = rs.repick() // randomly select axon
        for j = 0, 2 {
            if (x < 1/naxons_AA) {
                axon[j] { 
                    syn = new Exp2Syn(rx.repick()) 
                    syn.tau1 = 0.3	syn.tau2 = 2.9 syn.e = -28.99
                }
                syns_AA.append(syn)
                break
            } else {
                x = x - 1/naxons_AA
            }
        }
    }
    
    // HCC-GC synapses; location is IML
    for i=0, nsyns_HCC-1 {
        j = choose_index(PDidxs,PDweights,rs) // randomly select proximal dendrite
        dendrites[j] { 
            syn = new Exp2Syn(rx.repick()) 
            syn.tau1 = 0.04	syn.tau2 = 1.1	syn.e = -28.99
        }
        syns_HCC.append(syn)
    }
    
    // NGFC-GC synapses; location is MMML/MOML
    for i=0, nsyns_NGFC-1 {
        j = choose_index(MDDidxs,MDDweights,rs) // randomly select middle/distal dendrite
        x = rx.repick()
        dendrites[j] { 
            syn = new Exp2Syn(x) 
            syn.tau1 = 0.1	syn.tau2 = 10	syn.e = -38.148
            syns_NGFC_GABAA.append(syn)
            syn = new Exp2Syn(x) 
            syn.tau1 = 86.8	syn.tau2 = 428.1 syn.e = -90
            syns_NGFC_GABAB.append(syn)
        }
    }
    
    // LPP and MPP synapses are dynamically added via addSyn;
    /*
    for i=0, nDends-1 {
        dendrites[i] { 
            lst = new List()
            syns_LPP.append(lst)
            lst = new List()
            syns_MPP.append(lst)
        }
    }
    */
    
    soma {
        syn_stim = new ExpSyn(0.5)
        syn_stim.tau = 1
    }

}

external continuerun, cvode_active, cvode
obfunc syntest_up() { local vec_size, i_holding, w, idx localobj se, ns, nc, nclist, vec, synlist, results, tlog, nil
    
    synlist = $o1
    se = $o2
    w = $3
    v_holding = $4
    v_init = $5
    
    soma { 
        se.rs = 1
        se.dur1 = 3010
        se.amp1 = v_holding 
    }
    
    mainDT = 0.001
    dt = mainDT
    tstop = 3000
    
    vec_size = tstop/mainDT + 1
    
    vec = new Vector(vec_size)
    vec.record(&se.i)
    
    tlog = new Vector(vec_size)
    tlog.record(&t)
    
    ns = new NetStim()
    ns.interval = 3000
    ns.number = 1
    ns.start  = 2200
    ns.noise  = 0
    
    nclist = new List()
    for idx=0, synlist.count()-1 {
        nc = new NetCon(ns,synlist.o(idx))
        nc.weight = w
        nc.delay = 0
        nclist.append(nc)
    }
    
    cvode_active(1)
    cvode.use_daspk(1)
    cvode.dae_init_dteps(1e-9, 2)
    finitialize(v_init)
    fadvance()
    continuerun(tstop)

    
    i_holding = vec.x[tlog.indwhere(">=",ns.start)]
    idx = tlog.indwhere(">=",ns.start) - 1
    vec.remove(0,idx)
    tlog.remove(0,idx)
    
    vec.printf()
    tlog.printf()
    
    i_peak = vec.max()
    t_peak = tlog.x[vec.indwhere("==",i_peak)]
    
    print "i_peak = ", i_peak
    print "i_holding = ", i_holding
    print "i_peak - i_holding = ", i_peak - i_holding

    amp = abs(i_peak - i_holding) * 1000
    
    i_0001 = i_holding + (i_peak - i_holding) * 1/10000
    i_10 = i_holding + (i_peak - i_holding) * 1/10
    i_20 = i_holding + (i_peak - i_holding) * 2/10
    i_50 = i_holding + (i_peak - i_holding) * 5/10
    i_80 = i_holding + (i_peak - i_holding) * 8/10
    i_90 = i_holding + (i_peak - i_holding) * 9/10
    
    t_10_90 = tlog.x[vec.indwhere(">",i_90)] - tlog.x[vec.indwhere(">",i_10)]
    t_20_80 = tlog.x[vec.indwhere(">",i_80)] - tlog.x[vec.indwhere(">",i_20)]
    
    t_all = t_peak - tlog.x[(vec.indwhere(">",i_0001))]
    t_50  = t_peak - tlog.x[(vec.indwhere(">",i_50))]
    
    idx = vec.indwhere("==",i_peak) - 1
    if (idx >= 0) {
        vec.remove(0,idx)
        tlog.remove(0,idx)
    }
    
    i_t	= i_holding + ((1/exp(1)) * abs(i_peak - i_holding))
    t_decay = tlog.x[vec.indwhere("<",i_t)] - tlog.x[0]
    
    results = new Vector()
    results.append(amp,t_10_90,t_20_80,t_all,t_50,t_decay)
    
    ns = nil
    nc = nil
    
    return results
}


obfunc syntest() { local vec_size, i_holding, w, idx localobj se, ns, nc, nclist, vec, synlist, results, tlog, nil
    
    
    synlist = $o1
    se = $o2
    w = $3
    v_holding = $4
    v_init = $5
    
    soma { 
        se.rs = 10
        se.dur1 = 1010
        se.amp1 = v_holding 
    }
    
    mainDT = 0.001
    dt = mainDT
    tstop = 1000
    
    vec_size = tstop/mainDT + 1
    
    vec = new Vector(vec_size)
    vec.record(&se.i)
    
    tlog = new Vector(vec_size)
    tlog.record(&t)
    
    ns = new NetStim()
    ns.interval = 1000
    ns.number = 1
    ns.start  = 200
    ns.noise  = 0
    
    nclist = new List()
    for idx=0, synlist.count()-1 {
        nc = new NetCon(ns,synlist.o(idx))
        nc.weight = w
        nc.delay = 0
        nclist.append(nc)
    }
    
    cvode_active(1)
    cvode.use_daspk(1)
    cvode.dae_init_dteps(1e-9, 2)
    finitialize(v_init)
    fadvance()
    continuerun(tstop)
    
    i_holding = vec.x[tlog.indwhere(">=",ns.start)]
    idx = tlog.indwhere(">=",ns.start) - 1
    vec.remove(0,idx)
    tlog.remove(0,idx)
    
    vec.printf()
    tlog.printf()
    
    i_peak = vec.min()
    t_peak = tlog.x[vec.indwhere("==",i_peak)]
    
    print "i_peak = ", i_peak
    print "i_holding = ", i_holding
    print "i_peak - i_holding = ", i_peak - i_holding
    
    amp = abs(i_peak - i_holding) * 1000
    
    i_0001 = i_holding + (i_peak - i_holding) * 1/10000
    i_10 = i_holding + (i_peak - i_holding) * 1/10
    i_20 = i_holding + (i_peak - i_holding) * 2/10
    i_50 = i_holding + (i_peak - i_holding) * 5/10
    i_80 = i_holding + (i_peak - i_holding) * 8/10
    i_90 = i_holding + (i_peak - i_holding) * 9/10
    
    t_10_90 = tlog.x[vec.indwhere("<",i_90)] - tlog.x[vec.indwhere("<",i_10)]
    t_20_80 = tlog.x[vec.indwhere("<",i_80)] - tlog.x[vec.indwhere("<",i_20)]
    
    t_all = t_peak - tlog.x[(vec.indwhere("<",i_0001))]
    t_50  = t_peak - tlog.x[(vec.indwhere(">",i_50))]
    
    idx = vec.indwhere("==",i_peak) - 1
    if (idx >= 0) {
        vec.remove(0,idx)
        tlog.remove(0,idx)
    }
    
    i_t	= i_holding - ((1/exp(1)) * abs(i_peak - i_holding))
    t_decay = tlog.x[vec.indwhere(">",i_t)] - tlog.x[0]
    
    results = new Vector()
    results.append(amp,t_10_90,t_20_80,t_all,t_50,t_decay)
    
    ns = nil
    nc = nil
    
    return results
}


obfunc synpulsetest() { local vec_size, w, wsum, idx localobj ns, nc, nclist, vec, synlist, weights, results, tlog, r, nil
    
    
    synlist = $o1
    weights = $o2
    groupsize = $3
    v_init = $4
    
    r = new Random()
    r.discunif(0,synlist.count()-1)
    
    mainDT = 0.001
    dt = mainDT
    tstop = 1000
    
    vec_size = tstop/mainDT + 1
    
    vec = new Vector(vec_size)
    soma { vec.record(&v(0.5)) }
    
    tlog = new Vector(vec_size)
    tlog.record(&t)
    
    ns = new NetStim()
    ns.interval = 1
    ns.number = 1
    ns.start  = 200
    ns.noise  = 0
    
    nclist = new List()
    wsum = 0
    for idx=0, groupsize-1 {
        sidx = r.repick()
        nc = new NetCon(ns,synlist.o(sidx))
        nc.weight = weights.x[sidx]
        wsum = wsum + weights.x[sidx]
        nc.delay = 0
        nclist.append(nc)
    }
    printf("synpulsetest: wsum = %g\n", wsum)
    
    cvode_active(1)
    cvode.use_daspk(1)
    cvode.dae_init_dteps(1e-9, 2)
    finitialize(v_init)
    fadvance()
    continuerun(tstop)
    
    vec.printf()
    tlog.printf()
    
    ns = nil
    nc = nil
    
    return vec
}

